package CS486AI.A1Q3;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.PriorityQueue;



public class AStarSearch {
	private static int counter;	
	private static LinkedList<Node> expanded;
	private static PriorityQueue<Node> fringe;
	private static HashMap<Node,Node> predecessor;
	private static HashMap<Node,Double> gCost;
	private LinkedList<City> cityList;

	
	public AStarSearch(LinkedList<City> cityList){
		expanded = new LinkedList<Node> ();
		fringe = new PriorityQueue<Node>();
		
		predecessor = new HashMap<Node,Node>();
		gCost = new HashMap<Node,Double>();
		
		counter = 0;
		this.cityList = cityList;
	}
	
	public static int getCounter() {
		return counter;
	}
	
	public void printCounter(){
		
		System.out.println("# of generated path: " + counter);
	}
	
	public void getSolution(Node goalNode){	
		City city;
		System.out.print("TSP Solved Path: ");
		// Print TSP solution
		for (int i = 0; i < goalNode.getNodePath().size(); i++){
			city = goalNode.getNodePath().get(i);
			System.out.print(city.getName().toString() + " to ");
		}
		// back to A
		System.out.print("A");
	}
	
	public double traversalCost(Node cur, Node nextNode){
		City currentCity = cur.getNodePath().getLast();
		City nextCity = nextNode.getNodePath().getLast();
		
		// calculate the traversal cost
		double travelCost = City.traversalCost(currentCity, nextCity);
		return travelCost;
	}
	
	public Node TSPsearch(Node startNode){
		
		Node cur;
		// add and store start node
		fringe.add(startNode);
		predecessor.put(startNode, null);
		
		// cost of h(n) = 0;
		int cost  = 0;
		double costChecker = 0;
		gCost.put(startNode, costChecker);
		startNode.setTotalCost(cost);
	
		// SEARCH PROCESS
		// loop while there is still fringe nodes available
		while(!fringe.isEmpty()){
			// dequeue fringe and store as currentNode
			cur = fringe.remove();
			
			// Print node expanded
			System.out.print("Expanded node: ");
			for (int i = 0; i < cur.getNodePath().size(); i ++){
				City city = cur.getNodePath().get(i);
				System.out.print(city.getName().toString() + "---->");
			}
			System.out.println();
	
			if(cur.getNodePath().size() == this.cityList.size())
				return cur;
			
			// store a LL to track nodes that have been expanded
			expanded.add(cur);
			
			for (int i =0; i < cur.generateNeighbours(cityList).size(); i++){
				Node node = cur.generateNeighbours(cityList).get(i);

				// node is not in fringe queue, store it
				 if (!fringe.contains(node)){
					System.out.println("Processing new node path: ");
					fringe.add(node);
					
					// loop to process the node path and output
					for(int j =0; j < node.getNodePath().size(); j++){
						City city = node.getNodePath().get(j);
						System.out.print(city.getName() + "->");
					}
					//increment nodes generated by A* search
					counter++;
					System.out.println();
				}
				// Update Cost if its in fringe
				else{ 

					costChecker = gCost.get(cur) + traversalCost(cur, node);
					/*if (gCost.get(node) <= costChecker)
						continue;*/
					predecessor.put(node, cur);
					gCost.put(node, costChecker);
					node.setTotalCost(gCost.get(node) + 0);
				}
					
			}
		}
		return null;
	}
	
	
	
	public Node TSPSearch2(Node startNode){
		
		Node cur;
		// add and store start node
		fringe.add(startNode);
		predecessor.put(startNode, null);
		
		// cost of h(n) = 0;
		int cost  = 0;
		double costChecker = 0;
		gCost.put(startNode, costChecker);
		startNode.setTotalCost(cost);
	
		// SEARCH PROCESS
		// loop while there is still fringe nodes available
		while(!fringe.isEmpty()){
			// dequeue fringe and store as currentNode
			cur = fringe.remove();
			
			if(cur.getNodePath().size() == this.cityList.size())
				return cur;
			
			// store a LL to track nodes that have been expanded
			expanded.add(cur);
			
			for (int i =0; i < cur.generateNeighbours(cityList).size(); i++){
				Node node = cur.generateNeighbours(cityList).get(i);

				// node is not in fringe queue, store it
				 if (!fringe.contains(node)){
					fringe.add(node);
					
					//increment nodes generated by A* search
					counter++;
				}
				// Update Cost if its in fringe
				else{ 

					costChecker = gCost.get(cur) + traversalCost(cur, node);
					/*if (gCost.get(node) <= costChecker)
						continue;*/
					predecessor.put(node, cur);
					gCost.put(node, costChecker);
					node.setTotalCost(gCost.get(node) + 0);
				}
					
			}
		}
		return null;
	}
}
